## 2021-08-07

-   刷题：
    -   删除有序数组中的重复项
        -   双指针
    -   搜索插入位置
    -   环形数组是否存在循环
        -   

## 2021-08-08

-   刷题：
    -   最大子序和
        -   对子数组进行统计、操作可以想到的方法：双指针、前缀和、dp

## 2021-08-11

-   刷题
    -   超级丑数
    -   合并两个有序数组
    -   加一（加法进位模拟）
        -   进位，9 + 1进位，其他不进位
    -   在排序数组中查找元素的第一个和最后一个位置
        -   STL二分查找，lower_bound，upper_bound
        -   手动二分，模拟lower与upper
    -   三数之和
        -   先排序，在双指针
        -   排序过后怎么想：外循环i = 0 ~ n - 3，固定一个数；之后剩下的区域用双指针，left = i + 1， right = n - 1，转换成了在固定一个数的基础上，两数之和 == -该数这一个转换
    -   全排列
        -   递归，递归三大部分
            -   递归参数
            -   终止条件
            -   递归主体
    -   打家劫舍3
        -   二叉树memo：hash表做memo，在每次计算前，首先检查是否已经在memo上存着了，如果有，那么直接返回，如果没有，计算出值，然后再填到memo中
    -   排序算法，包括快排、归并、堆
    -   只出现一次数字2:
        -   注意用于储存位数的vector<int> cnt(32, 0)，cnt[i]对应的是nums[i]的第i位
    -   汉明距离
        -   将计算每一对的汉明距离转换为计算每一位的汉明距离
    -   解码异或后的排列
    -   岛屿数量
        -   主程序两个for循环，碰到岛屿，就cnt++，进入排除相连岛屿环节dfs
        -   dfs中
            -   越界处理
            -   visited标记处理（可原地）
            -   四周递归
    -   最长递增子序列

## 2021-08-12

-   刷题
    -   零钱兑换，拿最少的金币来得到target数目的钱
        -   极其相似：LIT（最长上升子序列）
    -   下一个排列
        -   画图
    -   搜索二维矩阵
    -   不同路径
    -   旋转数组
        -   与剑指offer string的区分！那个可以用切片
    -   三角形最小路径和
    -   N皇后
    -   跳跃游戏
    -   通过前序、中序遍历重构二叉树
        -   主要思路：利用前序遍历的第一个元素是rootVal，找到对应中序遍历的rootVal的下标idx
        -   那么就可以通过[left, idx - 1] idx [idx + 1, right]将中序遍历分成3个部分，rootVal做根节点，[left, rootVal - 1]左子树继续进入递归，返回值给到root->left，同理右子树
        -   返回root即是已经重建好的二叉树
    -   数组中缺失/多余的数字
        -   剑指offer 53

## 2021-08-13

-   **背包问题**：一定要分得清什么是背包（target），什么是物品（nums）
    -   0-1背包问题
        -   物品只能够选一次
        -   外循环物品，内循环背包
        -   内循环背包逆序（因为物品只有一次）
        -   初始化逆序
    -   完全背包问题
        -   物品可以无限选
        -   外循环物品，内循环背包
        -   内循环背包正序（因为物品无限）
        -   初始化正序
    -   组合背包问题
        -   物品可以无限选，需要考虑顺序
        -   外循环背包，内循环物品
        -   内循环背包正序（因为物品无限）
        -   初始化正序
    -   分组背包问题
        -   [【动态规划/背包问题】运用分组背包进行求解 - 掷骰子的N种方法 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/number-of-dice-rolls-with-target-sum/solution/dong-tai-gui-hua-bei-bao-wen-ti-yun-yong-axtf/)
-   存在重复元素III
    -   

## 2021-08-16

-   刷题：
    -   526.优美的排列
    -   221.最大正方形
    -   238.除自身以外数组的乘积
    -   

```c++
dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1
```

-   UML图
    -   虚线+箭头：实现
    -   实现+箭头：关联
    -   1：类名 2：变量 3：实现
-   builder桥接模式实现
-   普通（链式队列）/循环队列（数组）实现
    -   push
    -   pop
    -   front
    -   size
    -   empty
-   单链表实现
    -   find
    -   insert
    -   erase
    -   size
-   链式栈

## 2021-08-17

-   刷题：
    -   组合总和，排列组合dfs问题还可以用背包问题解决
    -   152.乘积最大子数组
    -   网格题，步骤是什么
    -   84.  柱状图中最大的矩形
    -   大数打印（见本地VSleetcode题解）
        -   可以模拟进位的方式，不过太慢了
        -   正确的姿势是全排列，比如说打印前n位的数，那么等价于求解前n位全排列，其中每位都可以选0-9
    -   128.最长连续序列
    -   134.加油站
    -   1013.  将数组分成和相等的三个部分
    -   插入区间
        -   思路很关键：1是按照[start, end]的start对整体进行排序，2是将没有改变的先插入到res中，然后再将新的newInterval插入并计算
    -   **堆相关的题目：**
        -   767.  重构字符串
    -   剑指 Offer 61. 扑克牌中的顺子
    -   剑指 Offer 31. 栈的压入、弹出序列
    -   1122. 数组的相对排序

## 2021-08-18

-   栈题目
    -   单调栈
-   队列题目
    -   单调队列
-   前缀和
    -   560. 和为K的子数组
    -   注意：
        -   前缀和怎样保证hash表中的一定是s[left]？先计算出来s[right]，即s[right] = sum，再查看hash表，再将sum插入hash表
        -   为了提升速度，前缀和用哈希表来储存
        -   前缀和哈希表key是前缀和大小，value不是idx！而是前缀和为key的个数！
-   双指针
    -   581. 最短无序连续子数组

## 2021-08-21

-   刷题

    -   541 反转字符串 II

        -   reverse可以用在vector与string上，左闭右开，迭代器
        -   翻转某个区间可以用start与end双指针，避免用n

    -   443压缩字符串

         left与right指针代表计数指针，指向的是第一个相同字母的开头和最后一个字母相同的后尾

         由于需要原地修改，因此我还需要另一个指针idx，代表当前在原地修改的位置

         算法流程

        ​    ①开始，让left与right先分别指向本次要统计的字母的左侧与右侧

        ​    ②原地修改第一个是字母，字母为：chars[idx++] = chars[left]，注意修改完后，不管有没有数字，idx都要++指向下一个

        ​    ③之后统计长度len = right - left;当len > 1时才往后面追加数字，否则不理会

        ​    ④当len > 1时，按len的10进制位进行统计，取出最后一位放入idx，接下来依次放入，由于取位需要从最低位开始取，又不允许额外空间储存，因此还需要用两个指针i,j来记录数字所占用的下标起始终止位，之后再用reverse函数进行调整

        ​    ⑤调整过后，j指向的是下一个idx的位置，因此idx = j

        ​    ⑥循环直到right >= n

    -   剑指 Offer 16. 数值的整数次方

        -   快速幂：x^n，首先保证x != 0，因为未定义。其次保证n是正数，否则就要用到x ^ n = (1 / 2) ^ (-n)来转换成正数
        -   利用递归求解，n = = 0 与n == 1时特殊递归终止。二分
        -   时间：O(logn) 空间：O(logn)

    -   剑指 Offer 19. 正则表达式匹配

        -   利用dp[i] [j]求解，当做是前i个字符与前j个字符是否相匹配，最难顶的是*，可以匹配任意多个前面的字符
            -   当dp[i] [j]的j字节不是'*'时，能匹配成功的只有两种情况，要不就是[i] [j]前面都匹配成功了，i, j对应的字符也相同；要不就是j对应的是万能的-字符
            -   当d[i] [j]的j字节是'*'时，能匹配成功有三种情况
                -   不理会k*这两个字符，看能不能匹配成功，即dp[i] [j - 2]是否能匹配成功
                -   k重复1次，看能不能匹配成功，即dp[i - 1] [j - 2] && i、j - 1对应字节相同
                -   最特殊的，-*情况，就是只要dp[i - 1] [j - 2]匹配成功，一定能保证dp[i] [j]匹配成功
                -   至于为什么要写成dp[i - 1] [j]，我就不知道了

    -   剑指 Offer 27. 二叉树的镜像

        -   镜像就是翻转
            -   终止条件：root == NULL
            -   递归主体：root->left = root->right经过镜像翻转后的节点值；root->right = root->left经过镜像翻转过后的节点值

    -   判断二叉树是否对称

        -   需要两个节点一起判断，需要两个节点存在，且值相等，并且他们两个的儿子节点也相等
            -   root1->left->val == root2->right->val
            -   root1->right->val == root2->left->val

    -   剑指 Offer 36. 二叉搜索树与双向链表

    -   剑指 Offer 38. 字符串的排列

        -   去重可以用排序/哈希表来解决，组合我会用排序解决，这个哈希表解决简单点儿

    -   ==剑指 Offer 46. 把数字翻译成字符串==注意可以用三种方法

        -   dp，dp[i] = dp[i - 1] + dp[i - 2] / dp[i - 1]
        -   dfs
        -   memo + dfs

    -   剑指 Offer 49. 丑数

## 2021-08-22

-   刷题

    -   剑指 Offer 52. 两个链表的第一个公共节点

        -   注意：设两个链表的节点数分别为a、b，公共区域节点数为c（有可能为0），那么a + c + b == b + c + a，因此从节点A出发，走到null时，换节点B，最后一定会相遇，至于相遇处，可能是NULL，也可能是一个真实的节点，返回该节点即可。

    -   剑指 Offer 54. 二叉搜索树的第k大节点

        -   简单的dfs遍历即可，要注意的是这样写法是错误的，因为res没有被接收到，直接被丢弃了，正确的做法应该是重新再写一个void dfs，再用一个变量去记录该值

            ```c++
            int kthLargest(TreeNode* root, int k) {
                if (root == NULL) return -1;
                kthLargest(root->right, k);
                cnt++;
                if (cnt == k) return root->val; //res
                kthLargest(root->left, k);
                return -1;
            }
            ```

    -   平衡二叉树

        -   自顶向底
        -   自底向顶

    -   剑指 Offer 57 - II. 和为s的连续正数序列

        -   前缀和
        -   双指针

    -   剑指 Offer 58 - II. 左旋转字符串

        -   充分利用string的+重载符号

    -   滑动窗口的最大值

        -   j --> 0-n - 1,i --> 1- k n - k
        -   用什么数据结构：双向队列，单调队列
        -   什么时候删除：i > 0时，也就是说至少i = 1时，才考虑前面的nums[i - 1]与dq.front()的关系
        -   什么时候插入双向队列：一循环，就插入
        -   什么时候将dq.front()送入res：当i == 0时

    -   剑指 Offer 62. 圆圈中最后剩下的数字

        -   最后一个数字的idx = 0
        -   从最后一轮开始反推，最后一轮剩2个人。那么(idx + m) % 2，就是最后一轮，幸存下来的人的下标

    -   剑指 Offer 67. 把字符串转换成整数

    ```c++
                res *= 10;
                res += str[idx] - '0';
    ```

    -   剑指 Offer 68 - II. 二叉树的最近公共祖先

        ```c++
        class Solution {
        public:
            TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
                if(root == NULL || root == p || root == q) return root; //终止条件
                auto left = lowestCommonAncestor(root->left, p, q);
                auto right = lowestCommonAncestor(root->right, p, q);
                if(left == NULL && right == NULL) return NULL; //说明left与right都没有pq
                else if(left == NULL && right != NULL) return right; //说明right有pq
                else if(left != NULL && right == NULL) return left; //说明left有pq
                else return root; //说明pq分立两侧
            }
        };
        ```


## 2021-08-23

-   上午：详细了解了git中的分支操作，包括创建，切换，合并，以及合并发生冲突后该怎么办
-   下午：git其他内容快速浏览、操作系统、计网快速浏览、排序算法、基本数据结构实现、浏览一遍原来错的题
