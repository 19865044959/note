## 设计模式问答

### 什么是设计模式？

-   设计模式是一套被反复使用、多数人知晓、经过分类、代码设计经验的总结

### 设计模式目的？

-   提高代码重用性，可拓展性，降低代码耦合度。

## 开闭原则

-   定义：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码情况下进行扩展

>   注：**软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类**。

## 工厂模式

**工厂定义**：用一个单独的类来创建实例的过程，就是工厂

### 简单工厂

-   定义：用一个工厂类来创建实例，并且把实例创建的所有逻辑都放在这个工厂里

<img src="../../pictures/20140304233530984" alt="img" style="zoom:67%;" />

-   缺点：由于工厂内包含创建所有实例的内部逻辑，因此工厂对修改不封闭，即新增产品就要修改工厂，不满足开闭原则（OCP原则）

```c++
#include <iostream>
using namespace std;

/* 定义手机类型 */
enum PRODUCTTYPE { OPPO, VIVO, HUAWEI };

/* 抽象产品phone */
class phoneBase
{
public:
	virtual ~phoneBase() {};
	virtual void show() = 0;
};

/* OPPO具体产品phone */
class OPPOPhone :public phoneBase
{
public:
	void show() { cout << "OPPO Phone" << endl; }
};

/* VIVO具体产品phone */
class VIVOPhone :public phoneBase
{
public:
	void show() { cout << "VIVO Phone" << endl; }
};

/* HUAWEI具体产品phone */
class HUAWEIPhone :public phoneBase
{
public:
	void show() { cout << "HUAWEI Phone" << endl; }
};

/* 手机工厂 */
class Factory
{
public:
	/* 根据相应的类型进行生产 */
	phoneBase* createPhone(PRODUCTTYPE type)
	{
		switch (type)
		{
		case OPPO:
			return new OPPOPhone(); // 生产OPPO手机
			break;
		case VIVO:
			return new VIVOPhone(); // 生产VIVO手机
			break;
		case HUAWEI:
			return new HUAWEIPhone(); // 生产HUAWEI手机
			break;
		default:break;
		}

	}
};

int main()
{
	Factory factory;

	phoneBase* p1 = factory.createPhone(OPPO);
	p1->show();
	phoneBase* p2 = factory.createPhone(VIVO);
	p2->show();
	phoneBase* p3 = factory.createPhone(HUAWEI);
	p3->show();

	delete p1;
	delete p2;
	delete p3;
	return 0;
}

```



### 工厂方法

-   定义：简单工厂将实例化所有细节全部放到了一个工厂中，不满足开闭原则。那么定义一个用于创建对象的工厂接口，将实例化工作推迟到子类中。

<img src="../../pictures/20140305103041500" alt="img" style="zoom:67%;" />

-   好处：可以使系统在不修改具体工厂类的情况下引进新的产品，所以它完全满足“开闭原则”，实现了程序的可拓展性

```c++
// 工厂方法
#include <iostream>
using namespace std;

/* 定义手机类型 */
enum PRODUCTTYPE { OPPO, VIVO, HUAWEI };

/* 抽象产品phone */
class phoneBase
{
public:
	virtual ~phoneBase() {};
	virtual void show() = 0;
};
/* OPPO具体产品phone */
class OPPOPhone :public phoneBase
{
public:
	void show() { cout << "OPPO Phone" << endl; }
};

/* VIVO具体产品phone */
class VIVOPhone :public phoneBase
{
public:
	void show() { cout << "VIVO Phone" << endl; }
};

/* HUAWEI具体产品phone */
class HUAWEIPhone :public phoneBase
{
public:
	void show() { cout << "HUAWEI Phone" << endl; }
};

/* 抽象工厂 */
class Factory
{
public:
	/* 提供抽象生产接口，由各个具体工厂实现 */
	virtual phoneBase* createPhone() = 0; //纯虚函数，没有函数体（没有实现）， = 0只是告诉系统，这是纯虚的，由于这是定义，因此需要加上分号;
};

/* OPPO工厂 —— 专门负责生产OPPO手机 */
class OPPOFactory : public Factory
{
public:
	phoneBase* createPhone()
	{
		return new OPPOPhone();
	}
};

/* VIVO工厂 —— 专门负责生产VIVO手机 */
class VIVOFactory : public Factory
{
public:
	phoneBase* createPhone()
	{
		return new VIVOPhone();
	}
};

/* HUAWEI工厂 —— 专门负责生产HUAWEI手机 */
class HUAWEIFactory : public Factory
{
public:
	phoneBase* createPhone()
	{
		return new HUAWEIPhone();
	}
};


int main()
{
	Factory* Ofactory = new OPPOFactory(); //多态的体现：动态多态，即重写
	phoneBase* p1 = Ofactory->createPhone();
	p1->show();

	Factory* Vfactory = new VIVOFactory();
	phoneBase* p2 = Vfactory->createPhone();
	p2->show();

	Factory* Hfactory = new HUAWEIFactory();
	phoneBase* p3 = Hfactory->createPhone();
	p3->show();

	delete p1;
	delete p2;
	delete p3;
	return 0;
}
```



### 抽象工厂

工厂方法模式只考虑生产同等级的产品，但是现实生活中工厂能生产多等级（种类）产品，比如手机厂可以生产手机、手机配件、芯片等等

-   定义：在工厂接口中，不仅可以生产同等级产品，还可以生产多个等级（种类）的产品

<img src="https://img-blog.csdn.net/20140305113756125" alt="img" style="zoom: 67%;" />

-   优点：可以在类内部对产品族中相关联多等级产品共同管理，而不必专门引入多个新的类来进行管理
-   缺点：增加一个新的产品时，所有工厂类都需要进行修改

```c++
// 抽象工厂
#include <iostream>
using namespace std;

/* 定义手机类型 */
enum PRODUCTTYPE { OPPO, VIVO, HUAWEI };

/* 定义其他产品类型：芯片、配件 */
enum OTHERTYPE { IC, CASE }; 

/* 定义抽象产品phone */
class phoneBase
{
public:
	virtual ~phoneBase() {};
	virtual void show() = 0;
};

/* OPPO具体产品phone */
class OPPOPhone :public phoneBase
{
public:
	void show() { cout << "OPPO Phone" << endl; }
};

/* VIVO具体产品phone */
class VIVOPhone :public phoneBase
{
public:
	void show() { cout << "VIVO Phone" << endl; }
};

/* HUAWEI具体产品phone */
class HUAWEIPhone :public phoneBase
{
public:
	void show() { cout << "HUAWEI Phone" << endl; }
};

/* 定义抽象产品OTHER */
class OTHERBase
{
public:
	virtual ~OTHERBase() {};
	virtual void show() = 0;
};

/* OPPO具体产品OTHER */
class OPPOOTHER :public OTHERBase
{
public:
	void show() { cout << "OPPO OTHER PRODUCT" << endl; }
};

/* VIVO具体产品OTHER */
class VIVOOTHER :public OTHERBase
{
public:
	void show() { cout << "VIVO OTHER PRODUCT" << endl; }
};

/* HUAWEI具体产品OTHER */
class HUAWEIOTHER :public OTHERBase
{
public:
	void show() { cout << "HUAWEI OTHER PRODUCT" << endl; }
};

/* 抽象工厂 : 提供了产品的生成方法。 */
class Factory
{
public:
	virtual phoneBase* createPhone() = 0;
	virtual OTHERBase* createOther() = 0;
};

/* OPPO具体工厂：实现了OPPO产品族的生成方法。 */
class OPPOFactory : public Factory
{
public:
	phoneBase* createPhone()
	{
		return new OPPOPhone();
	}

	OTHERBase* createOther()
	{
		return new OPPOOTHER();
	}
};

/* VIVO具体工厂：实现了VIVO产品族的生成方法。 */
class VIVOFactory : public Factory
{
public:
	phoneBase* createPhone()
	{
		return new VIVOPhone();
	}

	OTHERBase* createOther()
	{
		return new VIVOOTHER();
	}
};

/* HUAWEI具体工厂：实现了HUAWEI产品族的生成方法。 */
class HUAWEIFactory : public Factory
{
public:
	phoneBase* createPhone()
	{
		return new HUAWEIPhone();
	}

	OTHERBase* createOther()
	{
		return new HUAWEIOTHER();
	}
};


int main()
{
	OPPOFactory Ofactory;
	phoneBase* p1 = Ofactory.createPhone();
	OTHERBase* p2 = Ofactory.createOther();
	p1->show();
	p2->show();

	VIVOFactory Vfactory;
	phoneBase* p3 = Vfactory.createPhone();
	OTHERBase* p4 = Vfactory.createOther();
	p3->show();
	p4->show();

	HUAWEIFactory Hfactory;
	phoneBase* p5 = Hfactory.createPhone();
	OTHERBase* p6 = Hfactory.createOther();
	p5->show();
	p6->show();

	delete p1;
	delete p2;
	delete p3;
	delete p4;
	delete p5;
	delete p6;
	return 0;
}

```

### 问题汇总：

-   为什么要有工厂？不能一个抽象产品+具体产品就搞定了吗？
    -   因为产品的实例化是通过具体工厂来创建的，这起到了封装的作用，因为具体的产品的细节都交给工厂去处理，而不是暴露给使用者

## 单例模式

- 定义：保证某一个类只有一个实例（对象），并提供一个访问它的全局访问点

-   特点：
    -   单例模式类**只提供**私有构造函数
    -   类定义中含有一个该类的静态私有对象
    -   类中提供了一个静态公有方法用于创建或获取它本身的静态私有对象
    -   定义内嵌类，程序结束销毁类实例
    
-   应用场景：**只允许打开一个应用**的场景

    -   任务管理器
    -   回收站
    -   网站的计数器，一般也是采用单例模式，否则难以同步
    -   操作系统文件系统

- 为什么单例模式所提供的唯一方法（接口）是静态的？

  -   答：调用方法有2种，一种是实例 + ： 或 + ->，但是这在单例模式，不允许创建实例，因此行不通
  -   另一种方式就是作用域::方法名()，这种要求方法是静态的。又由于静态方法只能修改静态成员变量，因此唯一的实例也必须是静态的。

-   实现方法：
    -   饿汉：单例类定义时就已经进行实例化了
        -   特点：不会出现线程安全问题，但是由于单例类定义时就已经开始实例化了，资源耗费大
    
    ```c++
    class CSingleton
    {
    public:
        //静态共有成员函数来创建/获取私有实例
    	static CSingleton * getSingleton()
    	{
    		return msin;
    	}
    	
        //内嵌类来析构
    	class CDestroy
        {
        public:
            ~CDestroy()
            {
    			if(CSingleton::msin != NULL)
    			{
    				delete CSingleton::msin;
    				msin = NULL;
    				cout << "~CSingleton()" << endl;
    			}
            }
        };
    
        static CDestroy mDel; //内嵌类对象是静态公有对象
    
    private:
        //静态私有实例
    	static CSingleton * msin;
        
    	//构造函数被私有，无法利用构造函数创建多个实例
    	CSingleton() 
    	{
    		cout << "CSingleton()" << endl;
    	}
    };
    
    CSingleton* CSingleton :: msin = new CSingleton(); //定义在类外
    CSingleton::CDestroy mDel; //内嵌类对象定义
    
    int main()
    {
    	cout << "Process Begin" << endl;
    	CSingleton *s1 = CSingleton::getSingleton();
    	CSingleton *s2 = CSingleton::getSingleton();
    	cout << "s1 = " << s1 << endl << "s2 = "<< s2 << endl;
    	//delete s1;
    }
    
    ```
    
    -   懒汉：当第一次使用时才创建一个唯一的实例对象，从而延迟加载效果
        -   特点：容易出现线程安全问题，即一个单例类可能在多线程情况下出现>1个实例的情况
        -   解决：加互斥锁
    
    ```c++
    class CSingleton
    {
    public:
    
    	static CSingleton * getSingleton()
    	{
    		if(msin == NULL)//在这当2个线程一前一后判断这个语句时，会出现创建2个实例的情况出现
    		{
    			msin = new CSingleton();
    		}
    		return msin;
    	}
    
    	class CDestroy
        {
        public:
            ~CDestroy()
            {
    			if(CSingleton::msin != NULL)
    			{
    				delete CSingleton::msin;
    				cout << "~CSingleton()" << endl;
    			}   
            }
        };
    
        static CDestroy mDel;
    
    private:
    	static CSingleton * msin;
    
    	CSingleton() 
    	{
    		cout << "CSingleton()" << endl;
    	}
    };
    
    CSingleton* CSingleton :: msin = NULL;
    CSingleton::CDestroy mDel;
    
    int main()
    {
    	//CSingleton s1;
    	cout << "Process Begin" << endl;
    	CSingleton *s1 = CSingleton::getSingleton();
    	CSingleton *s2 = CSingleton::getSingleton();
    	cout << "s1 = " << s1 << endl << "s2 = "<< s2 << endl;
    }
    
    ```
    
    ```c++
    //example 2 Thread safe
    
    /**
     * The Singleton class defines the `GetInstance` method that serves as an
     * alternative to constructor and lets clients access the same instance of this
     * class over and over.
     */
    class Singleton
    {
    
        /**
         * The Singleton's constructor/destructor should always be private to
         * prevent direct construction/desctruction calls with the `new`/`delete`
         * operator.
         */
    private:
        static Singleton * pinstance_;
        static std::mutex mutex_;
    
    protected:
        Singleton(const std::string value): value_(value)
        {
        }
        ~Singleton() {}
        std::string value_;
    
    public:
        /**
         * Singletons should not be cloneable.
         */
        Singleton(Singleton &other) = delete;
        /**
         * Singletons should not be assignable.
         */
        void operator=(const Singleton &) = delete;
        /**
         * This is the static method that controls the access to the singleton
         * instance. On the first run, it creates a singleton object and places it
         * into the static field. On subsequent runs, it returns the client existing
         * object stored in the static field.
         */
    
        static Singleton *GetInstance(const std::string& value);
        /**
         * Finally, any singleton should define some business logic, which can be
         * executed on its instance.
         */
        void SomeBusinessLogic()
        {
            // ...
        }
        
        std::string value() const{
            return value_;
        } 
    };
    
    /**
     * Static methods should be defined outside the class.
     */
    
    Singleton* Singleton::pinstance_{nullptr};
    std::mutex Singleton::mutex_;
    
    /**
     * The first time we call GetInstance we will lock the storage location
     *      and then we make sure again that the variable is null and then we
     *      set the value. RU:
     */
    Singleton *Singleton::GetInstance(const std::string& value)
    {
        /*
        	lock_guard类模板一般与mutex搭配使用， 其作用：
        	0. 简化程序员的lock与unlock操作（lock_guard都帮你做好了）
        	1. lock_guard构造时，传入它的对象mutex_会被调用lock_guard的线程锁住
        	2. 在lock_guard被析构时，它所管理的mutex_对象会自动解锁
        */
        std::lock_guard<std::mutex> lock(mutex_);
        if (pinstance_ == nullptr)
        {
            pinstance_ = new Singleton(value);
        }
        return pinstance_;
    }
    
    void ThreadFoo(){
        // Following code emulates slow initialization.
        std::this_thread::sleep_for(std::chrono::milliseconds(1000));
        Singleton* singleton = Singleton::GetInstance("FOO");
        std::cout << singleton->value() << "\n";
    }
    
    void ThreadBar(){
        // Following code emulates slow initialization.
        std::this_thread::sleep_for(std::chrono::milliseconds(1000));
        Singleton* singleton = Singleton::GetInstance("BAR");
        std::cout << singleton->value() << "\n";
    }
    
    int main()
    {   
        std::cout <<"If you see the same value, then singleton was reused (yay!\n" <<
                    "If you see different values, then 2 singletons were created (booo!!)\n\n" <<
                    "RESULT:\n";   
        std::thread t1(ThreadFoo);
        std::thread t2(ThreadBar);
        t1.join();
        t2.join();
        
        return 0;
    }
    ```

## 你的项目中哪些地方用到了设计模式？

-   在上层轨迹设计上用到了**工厂方法模式**
-   在刚进入实验室时，写轨迹设计算法时，用的是一个函数trajectory，利用switch case方法来选择轨迹函数。这有一点不好的就是需要在原有的代码上进行修改，添加新的轨迹算法进去。有时候会影响到其他轨迹算法的运行。经过对C++逐渐学习，对C++有更深层的了解，也接触了一些设计模式的思想，现在我的上层轨迹规划算法代码结构：
-   一个基类trajectory，作为抽象产品类，里面存在规矩规划函数trajectory_step()，是虚函数，以及所有的轨迹规划需要用到的一些变量，比如三轴期望位置、速度、三轴剩余距离、三轴maxSpeed等等
-   多个子类hover、point_to_point、circle、dubins作为具体工厂产品类，里面重写了trajectory_step()函数，作为具体的轨迹实现函数，里面还私有一些轨迹所有的特殊变量，比如说circle中的转弯半径，剩余的角度，dubins曲线中的t、p、q变量
-   这些值是怎样作为期望值，传给内环的呢？以point_to_point为例子？
    -   我是将变量全部设为静态变量，通过调用工厂接口，来调用hover、point_to_point、circle、dubins的生产工厂，最终调用trajectory_step()函数，得到静态变量的值，将这些值当做期望值传给串极前馈pid控制环，控制飞机的姿态。
-   **好处是什么？**
    -   这样写出的代码可移植性高、可拓展性强，低耦合，比如说我想加入一个minimum_snap曲线，那么直接写一个轨迹子类minimum_snap，并在工厂里添加minimum_snap工厂，其他存在的代码比如hover、point_to_point、circle都不用改
